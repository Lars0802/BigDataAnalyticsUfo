\section{Forschungsfrage} \label{forschungsfrage}

Nachdem wir uns dazu entschlossen haben, die APIs des NCEI nicht mehr zu verwenden, haben wir uns auf die Suche nach neuen APIs und Anwendungen gemacht, um an für uns passende Wetterdaten zu kommen. Der Service von Meteostat passte dabei perfekt in unsere Planung. Die Abfrage von Wetterdaten erfolgte durch die Python-Library von Meteostat und bekam als Input den Zeitraum der gewünschten Daten, sowie den Längen- und den Breitengrad des gewünschten Ortes.

Um die entprechenden geographischen Koordinaten für die Abfragen zu erhalten, wurde die API von \enquote{MapQuest} verwendet. Als Parameter wurden das \code{city, state}-Tupel aus dem bereinigten Datensatz übergeben. Den Output bildeten ein Tupel aus den resultierenden Längen- und Breitengraden der gewünschten Orte. Um redundante Anfragen zu vermeiden, wurden zunächst einzigartige \code{city, state}-Paare aus dem Datensatz extrahiert. Somit reduzierte sich die Anzahl der zu bewältigenden Geocoding-Anfragen von 96~924 auf 25~234.

Mit den abgeschlossenen Geocoding-Anfragen waren alle benötigten Daten für die Anfragen an die Meteostat-Datenbank lokal verfügbar. Als Basis für die Abfragen galten die Daten aller Sichtungen \enquote{\code{sightings.csv}} mit dem Tripel \code{datetime, city, state}. Über das Tupel \code{city,}\\\code{state} wurden die entsprechenden Längen- und Breitengrade aus \enquote{\code{cities\textunderscore coords.csv}} für die entsprechende Anfrage als Punkt gespeichert. Als Richtwert für den Zeitpunkt der abzufragenden Wetterdaten gilt das Attribut \code{datetime}. Da Meteostat für jede Anfrage einen Start- und Endzeitpunkt benötigt, wird als Endzeitpunkt eine Sekunde auf den Startzeitpunkt addiert.

Für die eigentliche Abfrage der Wetterdaten wurden zwei varianten benutzt. Zum Ersten sich stündlich aktualisierende Daten und zum Zweiten sich täglich aktualisierende Daten. Der Ablauf der Anfrage ist in beiden Fällen identisch, der einzige Unterschied ist, dass die Condition Codes für den Himmel nur in den stündlichen Daten vorhanden waren. Da die Stationen nicht identisch sind, lieferte nicht jede Station für jedes relevante Attribut die entsprechenden Messwerte. Es wurden dementsprechend nur die Ergebnisse der Anfragen gespeichert, wenn einer der drei relevanten Werte vorhanden war. Die Ergebnisse der Anfrage bestanden letztendlich aus der Liste \code{city, state, time\textunderscore date, sun\textunderscore hourly, sun\textunderscore daily,}\\\code{condition\textunderscore code}, welche im letzten Schritt visualisiert wurden.

Die Visualisierungen erfolgten alle über die \enquote{matplotlib}-Library. Visualisiert wurden die drei Messwerte als Graph, die Condition Codes als Histogramm und Tortendiagramm sowie die stündlichen und täglichen Sonnenminuten als Boxplots.